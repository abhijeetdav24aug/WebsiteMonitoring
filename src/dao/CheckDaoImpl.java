package dao;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.HashMap;
import java.util.Map;

import com.mysql.jdbc.Connection;
import com.mysql.jdbc.PreparedStatement;

import classes.Check;
/**
 * 
 * Implementation of the CheckDao methods.
 * 
 * @author gabriellerappaport
 *
 */
public class CheckDaoImpl implements CheckDao {
	/**
	 * SQL query : for a given website
	 * <ul>
	 * <li> counts idChecks where httpStatusCode are Success for the past x seconds
	 * <li> counts idChecks for the past x seconds
	 * </ul>
	 */
	private static final String SQL_AVAILABILITY = "SELECT available, countAll, B.idWebsite "
			+ "FROM (SELECT COUNT(idCheck) AS available, idWebsite " + "FROM CheckWebsite WHERE idWebsite = ? "
			+ "AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND)) " + "AND httpStatusCode BETWEEN  200 AND 299) A "
			+ "RIGHT JOIN (SELECT COUNT(idCheck) AS countAll, idWebsite " + "FROM CheckWebsite  "
			+ "WHERE idWebsite = ? AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND))) B "
			+ "ON A.idWebsite = B.idWebsite";

	/**
	 *  SQL query : for a given website, for the last x seconds 
	 * <ul>
	 * <li> available : counts idChecks where httpStatusCode are Success in intervals of y seconds
	 * <li> allCount : counts idChecks in intervals of y seconds
	 * </ul>
	 */
	private static final String SQL_AVAILABILITY_LIST = "SELECT available, countAll, B.timestamp AS timestamp "
			+ "FROM (SELECT COUNT(idCheck) AS available, FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(date)/( ? ))* ? ) AS timestamp "
			+ "FROM CheckWebsite WHERE idWebsite = ? "
			+ "AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND)) AND httpStatusCode BETWEEN  200 AND 299 GROUP BY timestamp) A "
			+ "RIGHT JOIN (SELECT COUNT(idCheck) AS countAll, FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(date)/( ? ))* ? ) AS timestamp "
			+ "FROM CheckWebsite " + "WHERE idWebsite = ? " + "AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND)) "
			+ "GROUP BY timestamp) B " + "ON A.timestamp = B.timestamp";

	/**
	 * SQL query : for a given website
	 * computes the average response time on intervals of y seconds for the past x seconds.
	 */
	private static final String SQL_AVG_RESPONSE_LIST = "SELECT AVG(responseTime) AS avgResponseTime, FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(date)/( ? ))* ? ) AS timestamp "
			+ "FROM CheckWebsite " + "WHERE idWebsite = ? " + "AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND)) "
			+ "GROUP BY timestamp ORDER BY timestamp ASC";
	
	/**
	 * SQL query : for a given website
	 * counts the number of each httpStatusCode on intervals of y seconds for the past x seconds.
	 */
	private static final String SQL_CODE_COUNT_LIST = "SELECT httpStatusCode, COUNT(httpStatusCode) AS count,  FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(date)/( ? ))* ? ) AS timestamp  "
			+ "FROM CheckWebsite  WHERE idWebsite = ?  " + "AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND))  "
			+ "GROUP BY httpStatusCode, timestamp ORDER BY timestamp ASC";
	
	/**
	 * SQL query : delete a check in the database given its unique id
	 */
	private static final String SQL_DELETE_WEBSITE = "DELETE FROM CheckWebsite WHERE idWebsite = ?";
	
	/**
	 * SQL query : insert a check in the database
	 */
	private static final String SQL_INSERT = "INSERT INTO CheckWebsite (idCheck, httpStatusCode, responseTime, idWebsite, date) VALUES (?, ?, ?, ?, NOW())";
	
	/**
	 * SQL query : return the max idCheck
	 */
	private static final String SQL_MAX_ID = "SELECT MAX(idCheck) AS maxIdCheck FROM CheckWebsite";

	/**
	 * SQL query : for a given website
	 * computes the maximum response time on intervals of y seconds for the past x seconds.
	 */
	private static final String SQL_MAX_RESPONSE_LIST = "SELECT MAX(responseTime) AS maxResponseTime, FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(date)/( ? ))* ? ) AS timestamp "
			+ "FROM CheckWebsite WHERE idWebsite = ? " + "AND date > (SELECT DATE_SUB(NOW(), INTERVAL ? SECOND)) "
			+ "GROUP BY timestamp ORDER BY timestamp ASC";

	/**
	 * DAOFactory
	 */
	private DAOFactory daoFactory;

	/**
	 * Constructor of the CheckImplementation
	 * @param daoFactory
	 */
	public CheckDaoImpl(DAOFactory daoFactory) {
		this.daoFactory = daoFactory;
	}

	/**
	 * Add a check in the database
	 */
	@Override
	public void create(Check check) throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		PreparedStatement preparedStatementIdCheck = null;
		ResultSet autoGeneratedValues = null;
		ResultSet idCheckMax = null;
		Integer idCheck = 1;
		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			preparedStatementIdCheck = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_MAX_ID, false);
			idCheckMax = preparedStatementIdCheck.executeQuery();
			/* Retrieve the max idCheck in the database and increment it */
			while (idCheckMax.next()) {
				idCheck = (int) (idCheckMax.getLong("maxIdCheck") + 1);
			}
			
			/* Add check in the database */
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_INSERT, true, idCheck, check.getHttpStatusCode(), check.getResponseTime(),
					check.getIdWebsite());
			int statut = preparedStatement.executeUpdate();
			
			/* Analyze status returned by insertion request */
			if (statut == 0) {
				throw new DAOException("Failed to create the website, no added row in the table.");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtility.silentClosing(autoGeneratedValues, preparedStatement, connection);
		}
	}

	/**
	 * Delete a check from the database given its unique id
	 */
	@Override
	public void delete(Integer idWebsite) throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;

		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			/* Delete check from the database */ 
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_DELETE_WEBSITE, true, idWebsite);
			int statut = preparedStatement.executeUpdate();
			if (statut == 0) {
				throw new DAOException("Failed to delete checks, no rows deleted from the table.");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtility.silentClosing(preparedStatement, connection);
		}
	}

	/**
	 * Read the availability of a website in the past x seconds
	 */
	@Override
	public Double readAvailability(Integer idWebsite, Integer period) throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Double availability = null;

		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_AVAILABILITY, false, idWebsite, period, idWebsite, period);
			resultSet = preparedStatement.executeQuery();

			/* Computes availability with resultSet */ 
			if (resultSet.next()) {
				availability = (double) resultSet.getInt("available") / resultSet.getInt("countAll");
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtility.silentClosing(resultSet, preparedStatement, connection);
		}
		return availability;
	}

	/**
	 * Read the availability of a website in the past x seconds, on intervals of y seconds
	 */
	@Override
	public Map<java.util.Date, Double> readAvailability(Integer idWebsite, Integer period, Integer timeframe)
			throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Map<java.util.Date, Double> availability = new HashMap<>();

		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_AVAILABILITY_LIST, false, timeframe, timeframe, idWebsite, period, timeframe,
					timeframe, idWebsite, period);
			resultSet = preparedStatement.executeQuery();
			
			/* Compute availability with resulSet on the different time intervals */
			while (resultSet.next()) {
				availability.put(resultSet.getTimestamp("timestamp"),
						(double) resultSet.getInt("available") / resultSet.getInt("countAll"));
			}
		} catch (SQLException e) {
			System.out.println(e);
			throw new DAOException(e);
		} catch (ArithmeticException e) {
			System.out.println("Arithm√©tique");
		} finally {
			DAOUtility.silentClosing(resultSet, preparedStatement, connection);
		}
		return availability;
	}

	/**
	 * Read the average response time of a website in the past x seconds, on intervals of y seconds
	 */
	@Override
	public Map<java.util.Date, Integer> readAvgResponseTime(Integer idWebsite, Integer period, Integer timeframe)
			throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Map<java.util.Date, Integer> avgResponseTime = new HashMap<>();

		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_AVG_RESPONSE_LIST, false, timeframe, timeframe, idWebsite, period);
			resultSet = preparedStatement.executeQuery();

			/* Store average response time from resulSet on the different time intervals */
			while (resultSet.next()) {
				avgResponseTime.put(resultSet.getTimestamp("timestamp"), resultSet.getInt("avgResponseTime"));
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtility.silentClosing(resultSet, preparedStatement, connection);
		}
		return avgResponseTime;
	}

	/**
	 * Counts the number of each httpStatusCode on intervals of y seconds for the past x seconds.
	 */
	
	@Override
	public Map<java.util.Date, Map<Integer, Integer>> readCodesCount(Integer idWebsite, Integer period,
			Integer timeframe) throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Map<java.util.Date, Map<Integer, Integer>> codesCount = new HashMap<>();

		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_CODE_COUNT_LIST, false, timeframe, timeframe, idWebsite, period);
			resultSet = preparedStatement.executeQuery();

			while (resultSet.next()) {
				Timestamp timestamp = resultSet.getTimestamp("timestamp");
				Timestamp key1 = timestamp;
				Integer key2 = resultSet.getInt("httpStatusCode");
				Integer value = resultSet.getInt("count");
				if (codesCount.containsKey(key1)) {
					codesCount.get(key1).put(key2, value);
				} else {
					Map<Integer, Integer> map = new HashMap<>();
					map.put(key2, value);
					codesCount.put(key1, map);
				}
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtility.silentClosing(resultSet, preparedStatement, connection);
		}
		return codesCount;
	}

	/**
	 * Read the maximum response time of a website in the past x seconds, on intervals of y seconds
	 */
	
	@Override
	public Map<java.util.Date, Integer> readMaxResponseTime(Integer idWebsite, Integer period, Integer timeframe)
			throws DAOException {
		Connection connection = null;
		PreparedStatement preparedStatement = null;
		ResultSet resultSet = null;
		Map<java.util.Date, Integer> maxResponseTime = new HashMap<>();

		try {
			/* Recovering a connection from the Factory */
			connection = (Connection) this.daoFactory.getConnection();
			preparedStatement = (PreparedStatement) DAOUtility.initializationPreparedRequest(connection,
					CheckDaoImpl.SQL_MAX_RESPONSE_LIST, false, timeframe, timeframe, idWebsite, period);
			resultSet = preparedStatement.executeQuery();

			/* Store maximum response time from resulSet on the different time intervals */
			while (resultSet.next()) {
				maxResponseTime.put(resultSet.getTimestamp("timestamp"), resultSet.getInt("maxResponseTime"));
			}
		} catch (SQLException e) {
			throw new DAOException(e);
		} finally {
			DAOUtility.silentClosing(resultSet, preparedStatement, connection);
		}
		return maxResponseTime;
	}
}
